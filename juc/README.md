# 本模块选自《java并发编程实战》

## chapter1
### 1.1 前言

## chapter2
### 2.1 什么是线程安全性?
- 竞态条件(Race Condition)
  - 在[UnsafeSequence.java](src/cn/learn/juc/chapter1/UnsafeSequence.java)中存在竞态条件
  - 当某个计算的准确性取决于多个线程交替执行的时序，那么就会发生竞态条件
  - 最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能已经失效的观测结果来决定下一步操作：首先观测某个条件是否为真（例如文件X不存在），然后根据这个观察结果采取相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始筹建文件之间，观察结果可能变得无效（另一个线程在这个期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）
  - 使用“先检查后执行”的一种创建情况就是延迟初始化，延迟初始化的目的是将初始化操作到对象使用的时候才执行，同时确保只初始化一次
- 无状态的对象一定是线程安全的 例如Servlet 即两个线程之间没有共享状态
  - 例如Servlet没有状态（属性）， 所有的变量都只存在于线程栈的局部变量中，并且只能由当前线程访问，和其他线程并没有共享状态，就好像在访问不同的实例，由于线程访问无状态对象的行为并不会影响其他线程
- 不可变对象一定是线程安全的 (详见[WithPrivateFinalFiled.java](src/cn/learn/juc/chapter2/WithPrivateFinalFiled.java))
### 2.2 原子性
- [UnsafeSequence.java](src/cn/learn/juc/chapter1/UnsafeSequence.java)和[LazyInitRace.java](src/cn/learn/juc/chapter2/LazyInitRace.java)包含了一组需要以原子方式进行（或者说不可分割）的操作。要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或者之后读取和修改状态，而不是在修改状态的过程中。
- 复合操作：“先检查后执行”以及“读取-修改-写入”等操作称为复合操作；包含了一组必须以原子方式执行的操作已确保线程安全性
- 并发环境中的原子性与事务应用中的原子性具有相同的含义——一组语句被作为一个不可分割的单元被执行
### 2.3 加锁机制
#### 2.3.1 内置锁
- java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block），同步代码块包含两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized修饰的代码块就是一个同步代码块，它包含的代码块就是由这个锁保护的代码块，锁对象可以是任意的对象，但必须是同一个对象，否则将无法保证同步。来修饰的方法就锁一种横跨整个方法体的同步代码块。
  ```java
    // lock为锁的对象引用
    synchronized(lock){
        // 访问或修改由lock保护的共享状态
    }
    ```
  - 其中该同步代码块的锁就是这个方法调用所在的对象（对象锁/实例锁）
  - 静态的synchronized方法方法以Class对象作为锁（类锁）
  - 线程在加入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制流程退出还是通过抛出异常而退出，都会释放锁。
  - java的内置锁相当于锁一种互斥锁，这意味着最多最有一个线程能够持有这种锁，当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果线程B永远不释放锁，那么线程A也会永远地等下去。
#### 2.3.2 重入
- 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会被阻塞。然而，由于内置锁是可重入的，异常如果某个线程试图获取一个已经由它自己持有的锁，那么这个请求将会被允许，而不会阻塞。
- “重入”意味着获取锁的操作粒度锁“线程”，而不是“调用”
- 内部实现：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下这个锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。
### 2.4 用锁来保护状态
- 访问共享状态的复合操作，例如读取-修改-写入或者延迟初始化（先检查后执行），都必须锁原子操作以避免产生竞态条件。
- 如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。并且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。
  - 记住是所有位置，包括读取操作，详见[AtomicityTest.java](src/cn/learn/juc/chapter2/AtomicityTest.java)
  - 只有在写入共享变量才需要同步这个思想是错误的
- 常见加锁约定：将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的路径都进行同步，使得在该对象上不会发生并发访问。
- 当你在 Java 中对某个对象使用 synchronized 关键字获取该对象的锁时，锁定的并不是整个对象，而是对特定的 代码块或方法 进行同步控制。其他线程仍然可以访问该对象的未加锁部分，也就是说，锁定并不意味着对整个对象的独占访问。
- 并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。
- 当某个变量由锁保护时，意味着在每次访问这个变量时都需要首先获得锁，这样就确保在同一时刻只有一个线程可以访问这个变量，当类的不变性条件涉及多个状态变量时，那么还有另一个需求：在不变性条件中的每个变量都必须由同一个锁来保护。因此可以在单个原子操作访问或更新这些变量，从而确保不变性条件不被破坏。
- 示例：同步方法的复合不一定锁死线程安全
  ```java
    if (!list.contains(element))
        list.add(element)
   ```
  - 虽然contains和add等方法都是原子方法，但是在上面这个“如果不存在则添加(put-if-absent)”的操作中仍然存在竞态条件。
  - 虽然synchronized方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还需要额外的加锁机制。
### 2.5 活跃性与性能
- 通过缩小同步代码块的作用范围，我们可以很容易地做到既确保Servlet的并发性，同时又维护线程安全性。要确保同步代码块不要过小，并且不要讲本身应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享变量。

## chapter3
- synchronized关键字实现了原子性、内存可见性(Memory Visibility)以及确定临界区(Critical Section)
- 临界区：临界区是指一段需要独占访问共享资源的代码区。为了防止多个线程或进程在同一时间进入临界区，导致数据冲突或不一致，系统必须确保每次只有一个线程或进程进入临界区。
  - 临界区是指程序中的那部分代码，它们对共享资源进行访问，且不允许并发访问。
  - 多个线程或进程不能同时执行临界区的代码，需要互斥访问。
- 临界资源是被共享的资源，不能同时被多个线程或进程访问。
- 内存可见性：指在多线程环境中，一个线程对共享变量的修改，能及时被其他线程看到。
### 3.1 可见性
#### 3.1.1 重排序(Reordering)
- 在没有同步的情况下，编译器或者处理器为了提高性能，可能会对指令执行顺序进行优化（即指令重排序），但这可能会导致线程间的可见性问题。
- 在没有同步的情况下读取数据，类似于在数据库中使用READ——UNCOMMITED 隔离级别，因为在这种级别上将牺牲准确性以获取性能的提升。然而，在非同步的读取操作中则牺牲了更多的准确度，因为线程看到的共享变量值很容易失效。
#### 3.1.2 加锁与可见性
- 内置锁可以用于确保某一个线程以一种可预测的方式来查看另一个线程的执行结果：当线程A执行某个同步代码块块时，线程B随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A看到的变量值在B获取锁后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有执行结果。
- 同步代码块的可见性是由：对一个变量执行unlock之前，必须先把此变量同步回主内存中
- 现在，我们可以进一步理解为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果某一个线程在未持有正确锁的情况下读取某个变量，那么读取到的可能是一个失效值。
#### 3.1.3 volatile变量
- 这是一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明未volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总是回返回最新写入的值。
- volatile变量是轻量级的锁，它通过禁止指令重排序来保证可见性。
  - 这是因为访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量时一种比synchronized更轻量级的同步机制。
- 但是volatile并不是线程安全的，它不能保证原子性。
- volatile的最佳实践是和boolean类型使用。
- 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才使用volatile。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。
  - volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如初始化或关闭）。
- 当且仅当满足一下所有条件时，才应该使用volatile变量：
  - 对变量的写入操作不依赖变量的当前值，或者你能确保只有当个线程更新变量的值。
  - 该变量不会与其他状态变量一起纳入不变性条件中。即如果变量与其他状态变量之间存在依赖关系或约束，volatile 并不能保证变量之间的一致性（不变性条件）
  - 在访问变量时不需要加锁。
- 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。
### 3.2 发布与逸出
- 详见[UnsafeStates.java](src/cn/learn/juc/chapter3/escape/UnsafeStates.java)
- 当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态
### 3.3 线程封闭(Thread Confinement)
- 线程封闭是指在某个线程中，某个对象只能在该线程中访问，不能在另一个线程中访问。
- 线程封闭的常见应用时JDBC(Java Database Connectivity)的Connection对象。JDBC规范并不要求Connection对象必须是线程安全的。在典型的服务器应用程序中，线程从线程池中获取一个Connection对象，并且用该对象来处理请求，使用完后再将对象返还给线程池。由于大多数请求（例如Servlet请求）都是由单线程采用同步的方式来处理，并且在Connection对象返回之前，连接池不会再将它分配给其他线程，因此，这种连接管理模式在处理请求时隐含地将Connection对象封闭在线程中。
  - 因此，这种连接管理模式在处理请求时隐含地将Connection对象封闭在线程中。采用的是ThreadLocal技术，ThreadLocal 提供了一种将数据与当前线程绑定的机制，每个线程都有自己的独立副本
  - ThreadLocal 是一种很好的方式来封闭 Connection 对象，使得每个线程都有自己的 Connection，这样可以避免线程之间的竞争和资源共享问题。
#### 3.3.1 栈封闭
- 栈封闭是指在函数调用过程中，某个变量只能在当前栈帧中访问。
- 栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个变量。
#### 3.3.2 ThreadLocal类
- ThreadLocal类是JDK提供的一个线程封闭类，它为每个线程都创建了一个独立的变量副本，从而保证了线程安全。
- 维持线程封闭性的一种更规范的方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get和set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。
- ThreadLocal对象通常用于防止对可变的单示例变量(Singleton)或全局变量进行共享。例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都需要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会有属于自己的连接。
  - 详见[ThreadLocalApp.java](src/cn/learn/juc/chapter3/confine/ThreadLocalApp.java)
- 当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。
- ThreadLocal 对象本质上充当一个容器，帮助将线程与其内部保存的值关联起来。每个线程都有一个独立的 ThreadLocalMap，而 ThreadLocal 对象作为这个 Map 中的键，值就是我们通过 ThreadLocal 设置的值。
- 我们不能滥用ThreadLocal，它应该只用于那些在多个线程间共享的变量，例如，在多线程环境下，每个线程都有自己的数据库连接，每个线程都有自己的日志记录器，每个线程都有自己的线程池，等等。
- 它降低了代码的可重用性，并在类之间引入隐含的耦合性。
### 3.4 不变性
- 不变性是指对象在某个状态下，其状态不会被修改，并且该状态由构造函数去控制。
- 满足同步需求的另一个方法就是使用不可变对象（Immutable Object）
- 如果某个对象在此间后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性时不可变对象的固有属性之一。
  - 当不可变对象不一定时线程安全的
  - 构造函数是对象确保初始化的最后一道屏障
- 不可变性不等于将对象中的所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为final类型的域中可以保存对可变对象的引用。
- 当满足一下条件时，对象才是不可变的：
  - 对象此间后其状态不能被更改。
  - 对象的所有域都是final类型。
  - 对象时正确创建的（在对象的创建期间，this没有逸出）
- 
