# 本模块选自《java并发编程实战》

## chapter1
### 1.1 前言

## chapter2
### 2.1 什么是线程安全性?
- 竞态条件(Race Condition)
  - 在[UnsafeSequence.java](src/cn/learn/juc/chapter1/UnsafeSequence.java)中存在竞态条件
  - 当某个计算的准确性取决于多个线程交替执行的时序，那么就会发生竞态条件
  - 最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能已经失效的观测结果来决定下一步操作：首先观测某个条件是否为真（例如文件X不存在），然后根据这个观察结果采取相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始筹建文件之间，观察结果可能变得无效（另一个线程在这个期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）
  - 使用“先检查后执行”的一种创建情况就是延迟初始化，延迟初始化的目的是将初始化操作到对象使用的时候才执行，同时确保只初始化一次
- 无状态的对象一定是线程安全的 例如Servlet 即两个线程之间没有共享状态
  - 例如Servlet没有状态（属性）， 所有的变量都只存在于线程栈的局部变量中，并且只能由当前线程访问，和其他线程并没有共享状态，就好像在访问不同的实例，由于线程访问无状态对象的行为并不会影响其他线程
- 不可变对象一定是线程安全的 (详见[WithPrivateFinalFiled.java](src/cn/learn/juc/chapter2/WithPrivateFinalFiled.java))
### 2.2 原子性
- [UnsafeSequence.java](src/cn/learn/juc/chapter1/UnsafeSequence.java)和[LazyInitRace.java](src/cn/learn/juc/chapter2/LazyInitRace.java)包含了一组需要以原子方式进行（或者说不可分割）的操作。要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或者之后读取和修改状态，而不是在修改状态的过程中。
- 复合操作：“先检查后执行”以及“读取-修改-写入”等操作称为复合操作；包含了一组必须以原子方式执行的操作已确保线程安全性
- 并发环境中的原子性与事务应用中的原子性具有相同的含义——一组语句被作为一个不可分割的单元被执行
### 2.3 加锁机制
#### 2.3.1 内置锁
- java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block），同步代码块包含两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized修饰的代码块就是一个同步代码块，它包含的代码块就是由这个锁保护的代码块，锁对象可以是任意的对象，但必须是同一个对象，否则将无法保证同步。来修饰的方法就锁一种横跨整个方法体的同步代码块。
  ```java
    // lock为锁的对象引用
    synchronized(lock){
        // 访问或修改由lock保护的共享状态
    }
    ```
  - 其中该同步代码块的锁就是这个方法调用所在的对象（对象锁/实例锁）
  - 静态的synchronized方法方法以Class对象作为锁（类锁）
  - 线程在加入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制流程退出还是通过抛出异常而退出，都会释放锁。
  - java的内置锁相当于锁一种互斥锁，这意味着最多最有一个线程能够持有这种锁，当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果线程B永远不释放锁，那么线程A也会永远地等下去。
#### 2.3.2 重入
- 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会被阻塞。然而，由于内置锁是可重入的，异常如果某个线程试图获取一个已经由它自己持有的锁，那么这个请求将会被允许，而不会阻塞。
- “重入”意味着获取锁的操作粒度锁“线程”，而不是“调用”
- 内部实现：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下这个锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。
### 2.4 用锁来保护状态
- 访问共享状态的复合操作，例如读取-修改-写入或者延迟初始化（先检查后执行），都必须锁原子操作以避免产生竞态条件。
- 如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。并且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。
  - 记住是所有位置，包括读取操作，详见[AtomicityTest.java](src/cn/learn/juc/chapter2/AtomicityTest.java)
  - 只有在写入共享变量才需要同步这个思想是错误的
- 常见加锁约定：将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的路径都进行同步，使得在该对象上不会发生并发访问。
- 当你在 Java 中对某个对象使用 synchronized 关键字获取该对象的锁时，锁定的并不是整个对象，而是对特定的 代码块或方法 进行同步控制。其他线程仍然可以访问该对象的未加锁部分，也就是说，锁定并不意味着对整个对象的独占访问。
- 并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。
- 当某个变量由锁保护时，意味着在每次访问这个变量时都需要首先获得锁，这样就确保在同一时刻只有一个线程可以访问这个变量，当类的不变性条件涉及多个状态变量时，那么还有另一个需求：在不变性条件中的每个变量都必须由同一个锁来保护。因此可以在单个原子操作访问或更新这些变量，从而确保不变性条件不被破坏。
- 示例：同步方法的复合不一定锁死线程安全
  ```java
    if (!list.contains(element))
        list.add(element)
   ```
  - 虽然contains和add等方法都是原子方法，但是在上面这个“如果不存在则添加(put-if-absent)”的操作中仍然存在竞态条件。
  - 虽然synchronized方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还需要额外的加锁机制。
### 2.5 活跃性与性能
- 通过缩小同步代码块的作用范围，我们可以很容易地做到既确保Servlet的并发性，同时又维护线程安全性。要确保同步代码块不要过小，并且不要讲本身应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享变量。

## chapter3
- synchronized关键字实现了原子性、内存可见性(Memory Visibility)以及确定临界区(Critical Section)
- 临界区：临界区是指一段需要独占访问共享资源的代码区。为了防止多个线程或进程在同一时间进入临界区，导致数据冲突或不一致，系统必须确保每次只有一个线程或进程进入临界区。
  - 临界区是指程序中的那部分代码，它们对共享资源进行访问，且不允许并发访问。
  - 多个线程或进程不能同时执行临界区的代码，需要互斥访问。
- 临界资源是被共享的资源，不能同时被多个线程或进程访问。
- 内存可见性：指在多线程环境中，一个线程对共享变量的修改，能及时被其他线程看到。
### 3.1 可见性
#### 3.1.1 重排序(Reordering)
- 在没有同步的情况下，编译器或者处理器为了提高性能，可能会对指令执行顺序进行优化（即指令重排序），但这可能会导致线程间的可见性问题。
- 在没有同步的情况下读取数据，类似于在数据库中使用READ——UNCOMMITED 隔离级别，因为在这种级别上将牺牲准确性以获取性能的提升。然而，在非同步的读取操作中则牺牲了更多的准确度，因为线程看到的共享变量值很容易失效。
#### 3.1.2 加锁与可见性
- 内置锁可以用于确保某一个线程以一种可预测的方式来查看另一个线程的执行结果：当线程A执行某个同步代码块块时，线程B随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A看到的变量值在B获取锁后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有执行结果。
- 同步代码块的可见性是由：对一个变量执行unlock之前，必须先把此变量同步回主内存中
- 现在，我们可以进一步理解为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果某一个线程在未持有正确锁的情况下读取某个变量，那么读取到的可能是一个失效值。
#### 3.1.3 volatile变量
- 这是一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明未volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总是回返回最新写入的值。
- volatile变量是轻量级的锁，它通过禁止指令重排序来保证可见性。
  - 这是因为访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量时一种比synchronized更轻量级的同步机制。
- 但是volatile并不是线程安全的，它不能保证原子性。
- volatile的最佳实践是和boolean类型使用。
- 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才使用volatile。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。
  - volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如初始化或关闭）。
- 当且仅当满足一下所有条件时，才应该使用volatile变量：
  - 对变量的写入操作不依赖变量的当前值，或者你能确保只有当个线程更新变量的值。
  - 该变量不会与其他状态变量一起纳入不变性条件中。即如果变量与其他状态变量之间存在依赖关系或约束，volatile 并不能保证变量之间的一致性（不变性条件）
  - 在访问变量时不需要加锁。
- 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。
### 3.2 发布与逸出
- 详见[UnsafeStates.java](src/cn/learn/juc/chapter3/escape/UnsafeStates.java)
- 当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态
### 3.3 线程封闭(Thread Confinement)
- 线程封闭是指在某个线程中，某个对象只能在该线程中访问，不能在另一个线程中访问。
- 线程封闭的常见应用时JDBC(Java Database Connectivity)的Connection对象。JDBC规范并不要求Connection对象必须是线程安全的。在典型的服务器应用程序中，线程从线程池中获取一个Connection对象，并且用该对象来处理请求，使用完后再将对象返还给线程池。由于大多数请求（例如Servlet请求）都是由单线程采用同步的方式来处理，并且在Connection对象返回之前，连接池不会再将它分配给其他线程，因此，这种连接管理模式在处理请求时隐含地将Connection对象封闭在线程中。
  - 因此，这种连接管理模式在处理请求时隐含地将Connection对象封闭在线程中。采用的是ThreadLocal技术，ThreadLocal 提供了一种将数据与当前线程绑定的机制，每个线程都有自己的独立副本
  - ThreadLocal 是一种很好的方式来封闭 Connection 对象，使得每个线程都有自己的 Connection，这样可以避免线程之间的竞争和资源共享问题。
#### 3.3.1 栈封闭
- 栈封闭是指在函数调用过程中，某个变量只能在当前栈帧中访问。
- 栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个变量。
#### 3.3.2 ThreadLocal类
- ThreadLocal类是JDK提供的一个线程封闭类，它为每个线程都创建了一个独立的变量副本，从而保证了线程安全。
- 维持线程封闭性的一种更规范的方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get和set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。
- ThreadLocal对象通常用于防止对可变的单示例变量(Singleton)或全局变量进行共享。例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都需要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会有属于自己的连接。
  - 详见[ThreadLocalApp.java](src/cn/learn/juc/chapter3/confine/ThreadLocalApp.java)
- 当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。
- ThreadLocal 对象本质上充当一个容器，帮助将线程与其内部保存的值关联起来。每个线程都有一个独立的 ThreadLocalMap，而 ThreadLocal 对象作为这个 Map 中的键，值就是我们通过 ThreadLocal 设置的值。
- 我们不能滥用ThreadLocal，它应该只用于那些在多个线程间共享的变量，例如，在多线程环境下，每个线程都有自己的数据库连接，每个线程都有自己的日志记录器，每个线程都有自己的线程池，等等。
- 它降低了代码的可重用性，并在类之间引入隐含的耦合性。
### 3.4 不变性
- 不变性是指对象在某个状态下，其状态不会被修改，并且该状态由构造函数去控制。
- 满足同步需求的另一个方法就是使用不可变对象（Immutable Object）
- 不可变对象一定是线程安全的
- 如果某个对象在此间后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性时不可变对象的固有属性之一。
  - 当不可变对象不一定时线程安全的
  - 构造函数是对象确保初始化的最后一道屏障
- 不可变性不等于将对象中的所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为final类型的域中可以保存对可变对象的引用。
  - 详见[ImmutableApp.java](src/cn/learn/juc/chapter3/ImmutableApp.java)
  - 还得看final修饰的域持有的对象是否也是不可变对象
- 当满足一下条件时，对象才是不可变的：
  - 对象创建后其状态不能被更改
  - 对象的所有域都是final类型
  - 对象时正确创建的（在对象的创建期间，this没有逸出）
#### 3.4.1 final域
- final类型的域锁不可修改的，但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的。
- 在jaa内存模型中，final能确保初始化过程中的安全性，从而可以不受限地访问不可变对象，并且共享这些对象时无需同步。
  - final的可见性是指被final修饰的字段在构造器中一旦被初始化了，并且构造器没有把“this”的引用传递出去，那么在其他线程中就能看到final字段的值。
- 每当需要对一组相关数据以原子的方式执行某个操作时，都可以考虑创建一个不可变的类来包含这些数据。
- 对于在访问和更新对歌相关变量时出现的竞争条件问题，可以通过将这些变量保存在一个不可变对象中来消除。
  - 如果是一个可变对象，那么就必须使用锁来确保原子性。
  - 如果是一个不可变对象，那么当线程获得了对该对象的引用后，就不必担心另一个线程修改了该对象的状态
### 3.5 安全发布
- 到目前为止，我们重点讨论的是如何确保对象不被发布，例如让对象封闭在线程或另一个对象的内部。
- 某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。
- 要安全地发布一个对象下，对象的引用以及对象的状态必须同时对其他线程可见，一个正确构造的对象可以通过以下方式来安全地发布：
  - 在静态初始化函数中初始化一个对象引用
  - 将对象的引用保存到volatile类型的域或者AtomicReference对象中
  - 将对象的引用保存到某个正确构造对象的final类型域中
  - 将对象的引用保存到一个由锁保护的域中
- 通常情况下，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：
  ```java
    public static Holder holder = new Holder(42);
   ```
- 静态初始化器是由JVM在类初始化阶段执行。由于在JVM内部存在同步机制，因此通过这种方式可以被安全发布。
#### 3.5.1 可变对象
- 如果对象在构造后可以修改，那么安全发布只能保证“发布当时”状态的可见性
- 对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性
- 要安全地共享可变对象，这些对象必须被安全地发布，并且必须时线程安全的或者由某个锁保护起来

#### 3.5.2 总结
在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
- 线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
- 只读共享：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象（只读对象）。
- 线程安全共享：线程安全的对象在内部实现同步，因此多个线程可以通过对象的公开方法来访问而不需要进一步的同步。
- 保护对象：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

## chapter4-对象的组合
### 4.1 设计线程安全的类
- 在操作中还会包含一些后验条件来判断状态迁移是否是有效的。如果Counter的当前状态为17，那么下一个有效状态只能是18。当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。
- 并非所有的操作都会在状态转换上施加限制，例如，当更新一个保存当前温度的变量时，该变量正确的状态并不会影响计算结果。
#### 4.1.1 依赖状态的操作
- 类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（Precondition）。例如，不能从空队列中移除一个元素，在删除元素前，队列必须处理“非空的”状态。
- 如果在某个操作中包含有基于状态的先验条件，那么这个操作被称为依赖状态的操作。
- 在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中，先验条件可能会由于其他线程执行 的操作而变为真。在并发程序中要一直等到先验条件为真，然后再执行该操作。
### 4.2 实例封闭
- 如果某个类不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用。你可以确保该对象只能由单个线程访问（线程封闭），或者通过一个锁保护对该对象的所有访问。
- 封装简化了线程安全类的实现过程，它提供了一种实例封闭机制（Instance Confinement），通常也简称为“封闭”。
- 被封装对象一定不能超出它们既定的作用域。对象可以封闭在类的一个实例（例如作为类的一个私有成员）中，或者封闭在某个作用域内（例如作为一个局部变量），再或者封闭在线程内（例如在某个线程中将对象从一个方法传递到另一个方法，而不是多个线程之间共享该对象）。
- 实例封闭式构建线程安全类的最简单的一个方式，他还使得在锁策略的选择上拥有更多的灵活性。在Person中使用它的内置锁保护它的状态，但对于其他形式的锁来说，只要自始至终都使用同一个锁，就可以保护状态。
- 实例封闭还使得不同的状态变量可以由不同的锁来保护。
#### 4.2.1 监视器模式
- java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态，如下给出了如何使用私有锁来保护状态。
  ```java
    public class PrivateLock {
        private final Object myLock = new Object();
        private String widget;
        void someMethod() {
            synchronized (myLock) {
                // 访问或修改widget的状态
            }
        }
    }
   ```
- 使用私有的锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁），有许多优点。私有的锁对象可以将锁封装起来，使客户端无法得到锁，但客户端代码可以通过公有方法来访问锁，以便参与到它的同步策略中。
- 也可以通过在返回客户端代码之前复制可变的数据来维持线程安全性，如[SafeStates.java](src/cn/learn/juc/chapter3/immutable/SafeStates.java)，通常情况下，这并不存在性能问题，但在某些情况下，例如在处理大文件时，可能会导致内存溢出。
  - 因为每次创建一个新对象，所以每次调用都会创建一个新的对象，并且每次调用都会复制一份数据。虽然实际的数据发生了变化，但是返回的信息却保持不变。
### 4.3 为现有类添加原子操作
#### 4.3.1 客户端加锁
- 客户端加锁是指，对于使用某个对象X的客户端代码，使用X本身用户保护其状态的锁来保护这段客户端代码。
#### 4.3.2 组合
- 当为现有的类添加一个原子操作时，有一个更好的方法：组合（Composition），例如ImprovedList通过将List对象的操作委托给底层的List实例来实现List的操作。
- ImproveList通过自身的内置锁增加了一层额外的加锁，它并不关心底层的List是否是线程安全的，即使List不是线程安全的活着修改了它的加锁实现，ImprovedList也会提供一致的加锁机制来实现线程安全性。
## chapter5-基础构建模块
### 5.1 同步容器类
- 同步容器类包括Vector和HashTable，这些同步的封装器类是由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态全部封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。
#### 5.1.1 同步容器类的问题
- 同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。
- 容器创建的复合操作包括
  - 迭代（反复访问元素，直到遍历完容器内所有元素）
  - 跳转（根据指定顺序做到当前元素的下一个元素）
  - 条件运算，例如“若没有则添加”（检查在Map中是否存在键值K，如果没有，则加入键值对(K,V)）。
- 在同步容器类中，这些复合操作在没有客户端加锁的情况下表面上看是线程安全的，但当其他线程并发地修改容器时，它们可能会表现出意料之外的行为。例如，在迭代过程中，如果另一个线程删除了当前元素，那么迭代器将抛出ConcurrentModificationException。
- 同步容器类要遵守同步策略，即支持客户端加锁，因此可能会产生一些新的操作，只要我们知道应该使用哪一种锁，那么这些新操作就与容器的其他操作一样帅原子操作。
- 同步容器类通过其自身的锁来保护它的每个方法。通过获取容器类的锁，我们可以使getList和delList称为原子操作，并确保Vector的大小在调用size和get之间不会发生变化。
  - 详见[VectorV1.java](src/cn/learn/juc/chapter5/VectorV1.java)和[VectorV2.java](src/cn/learn/juc/chapter5/VectorV2.java)
- 在迭代操作时正确性要依赖于运气，即在调用size和get之间没有线程会修改Vector。在单线程环境中，这种假设完全成立，但在有其他线程并发地修改Vector时，则可能导致麻烦。
  - 与getList一样，如果在对Vector进行迭代时，另一个线程删除了一个元素，并且这两个操作交替执行，那么这种迭代方法将抛出ArrayIndexOutOfBoundsException异常。
#### 5.1.2 迭代器与ConcurrentModificationException
- 对容器类进行迭代的标准方式是使用Iterator，如果在迭代时，有其他线程并发地修改容器，那么即使是使用迭代器也无法避免在迭代期间对容器加锁。应该是在设计同步容器类的迭代器时并没有考虑到并发修改的问题，并且它们表现出的行为时“及时失败”（fail-fast）的。
- 这意味着，当它们发现容器在迭代过程中被修改时，就会抛出一个ConcurrentModificationException
  - 使用java8的foreach内部迭代，可以避免这种问题。
- 这种“及时失败”的迭代器并不是一种完备的处理机制，而只是”善意地“捕获并发错误，因此只能作为并发问题的预警指示器。它们采用的实现方式是，将计数器的变化与容器关联起来：如果在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException。然而，这种监察室在没有同步的情况下进行的，因此可能会看到失效的计数值，而迭代器可能并没有意识到已经发生了修改。
### 5.2 并发容器
