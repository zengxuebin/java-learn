# 本模块选自《java并发编程实战》

## chapter1
### 1.1 前言

## chapter2
### 2.1 什么是线程安全性?
- 竞态条件(Race Condition)
  - 在[UnsafeSequence.java](src/cn/learn/juc/chapter1/UnsafeSequence.java)中存在竞态条件
  - 当某个计算的准确性取决于多个线程交替执行的时序，那么就会发生竞态条件
  - 最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能已经失效的观测结果来决定下一步操作：首先观测某个条件是否为真（例如文件X不存在），然后根据这个观察结果采取相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始筹建文件之间，观察结果可能变得无效（另一个线程在这个期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）
  - 使用“先检查后执行”的一种创建情况就是延迟初始化，延迟初始化的目的是将初始化操作到对象使用的时候才执行，同时确保只初始化一次
- 无状态的对象一定是线程安全的 例如Servlet 即两个线程之间没有共享状态
  - 例如Servlet没有状态（属性）， 所有的变量都只存在于线程栈的局部变量中，并且只能由当前线程访问，和其他线程并没有共享状态，就好像在访问不同的实例，由于线程访问无状态对象的行为并不会影响其他线程
- 不可变对象一定是线程安全的 (详见[WithPrivateFinalFiled.java](src/cn/learn/juc/chapter2/WithPrivateFinalFiled.java))
### 2.2 原子性
- [UnsafeSequence.java](src/cn/learn/juc/chapter1/UnsafeSequence.java)和[LazyInitRace.java](src/cn/learn/juc/chapter2/LazyInitRace.java)包含了一组需要以原子方式进行（或者说不可分割）的操作。要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或者之后读取和修改状态，而不是在修改状态的过程中。
- 复合操作：“先检查后执行”以及“读取-修改-写入”等操作称为复合操作；包含了一组必须以原子方式执行的操作已确保线程安全性
- 并发环境中的原子性与事务应用中的原子性具有相同的含义——一组语句被作为一个不可分割的单元被执行
### 2.3 加锁机制
#### 2.3.1 内置锁
- java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block），同步代码块包含两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized修饰的代码块就是一个同步代码块，它包含的代码块就是由这个锁保护的代码块，锁对象可以是任意的对象，但必须是同一个对象，否则将无法保证同步。来修饰的方法就锁一种横跨整个方法体的同步代码块。
  ```java
    // lock为锁的对象引用
    synchronized(lock){
        // 访问或修改由lock保护的共享状态
    }
    ```
  - 其中该同步代码块的锁就是这个方法调用所在的对象（对象锁/实例锁）
  - 静态的synchronized方法方法以Class对象作为锁（类锁）
  - 线程在加入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制流程退出还是通过抛出异常而退出，都会释放锁。
  - java的内置锁相当于锁一种互斥锁，这意味着最多最有一个线程能够持有这种锁，当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果线程B永远不释放锁，那么线程A也会永远地等下去。
#### 2.3.2 重入
- 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会被阻塞。然而，由于内置锁是可重入的，异常如果某个线程试图获取一个已经由它自己持有的锁，那么这个请求将会被允许，而不会阻塞。
- “重入”意味着获取锁的操作粒度锁“线程”，而不是“调用”
- 内部实现：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下这个锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。
### 2.4 用锁来保护状态
- 访问共享状态的复合操作，例如读取-修改-写入或者延迟初始化（先检查后执行），都必须锁原子操作以避免产生竞态条件。
- 如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。并且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。
  - 记住是所有位置，包括读取操作，详见[AtomicityTest.java](src/cn/learn/juc/chapter2/AtomicityTest.java)
  - 只有在写入共享变量才需要同步这个思想是错误的
- 常见加锁约定：将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的路径都进行同步，使得在该对象上不会发生并发访问。
- 当你在 Java 中对某个对象使用 synchronized 关键字获取该对象的锁时，锁定的并不是整个对象，而是对特定的 代码块或方法 进行同步控制。其他线程仍然可以访问该对象的未加锁部分，也就是说，锁定并不意味着对整个对象的独占访问。
- 并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。
- 当某个变量由锁保护时，意味着在每次访问这个变量时都需要首先获得锁，这样就确保在同一时刻只有一个线程可以访问这个变量，当类的不变性条件涉及多个状态变量时，那么还有另一个需求：在不变性条件中的每个变量都必须由同一个锁来保护。因此可以在单个原子操作访问或更新这些变量，从而确保不变性条件不被破坏。
- 示例：同步方法的复合不一定锁死线程安全
  ```java
    if (!list.contains(element))
        list.add(element)
   ```
  - 虽然contains和add等方法都是原子方法，但是在上面这个“如果不存在则添加(put-if-absent)”的操作中仍然存在竞态条件。
  - 虽然synchronized方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还需要额外的加锁机制。
### 2.5 活跃性与性能
- 通过缩小同步代码块的作用范围，我们可以很容易地做到既确保Servlet的并发性，同时又维护线程安全性。要确保同步代码块不要过小，并且不要讲本身应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享变量。

## chapter3
- synchronized关键字实现了原子性、内存可见性(Memory Visibility)以及确定临界区(Critical Section)
- 临界区：临界区是指一段需要独占访问共享资源的代码区。为了防止多个线程或进程在同一时间进入临界区，导致数据冲突或不一致，系统必须确保每次只有一个线程或进程进入临界区。
  - 临界区是指程序中的那部分代码，它们对共享资源进行访问，且不允许并发访问。
  - 多个线程或进程不能同时执行临界区的代码，需要互斥访问。
- 临界资源是被共享的资源，不能同时被多个线程或进程访问。
- 内存可见性：指在多线程环境中，一个线程对共享变量的修改，能及时被其他线程看到。
### 3.1 可见性
#### 3.1.1 重排序(Reordering)
- 在没有同步的情况下，编译器或者处理器为了提高性能，可能会对指令执行顺序进行优化（即指令重排序），但这可能会导致线程间的可见性问题。
- 在没有同步的情况下读取数据，类似于在数据库中使用READ——UNCOMMITED 隔离级别，因为在这种级别上将牺牲准确性以获取性能的提升。然而，在非同步的读取操作中则牺牲了更多的准确度，因为线程看到的共享变量值很容易失效。
#### 3.1.2 加锁与可见性
- 内置锁可以用于确保某一个线程以一种可预测的方式来查看另一个线程的执行结果：当线程A执行某个同步代码块块时，线程B随后进入由同一个锁保护的同步代码块，在这种情况下可以保证，在锁被释放之前，A看到的变量值在B获取锁后同样可以由B看到。换句话说，当线程B执行由锁保护的同步代码块时，可以看到线程A之前在同一个同步代码块中的所有执行结果。
- 同步代码块的可见性是由：对一个变量执行unlock之前，必须先把此变量同步回主内存中
- 现在，我们可以进一步理解为什么在访问某个共享且可变的变量时要求所有线程在同一个锁上同步，就是为了确保某个线程写入该变量的值对于其他线程来说都是可见的。否则，如果某一个线程在未持有正确锁的情况下读取某个变量，那么读取到的可能是一个失效值。
#### 3.1.3 volatile变量
- 这是一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明未volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总是回返回最新写入的值。
- volatile变量是轻量级的锁，它通过禁止指令重排序来保证可见性。
  - 这是因为访问volatile变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此volatile变量时一种比synchronized更轻量级的同步机制。
- 但是volatile并不是线程安全的，它不能保证原子性。
- volatile的最佳实践是和boolean类型使用。
- 仅当volatile变量能简化代码的实现以及对同步策略的验证时，才使用volatile。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。
  - volatile变量的正确使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如初始化或关闭）。
- 当且仅当满足一下所有条件时，才应该使用volatile变量：
  - 对变量的写入操作不依赖变量的当前值，或者你能确保只有当个线程更新变量的值。
  - 该变量不会与其他状态变量一起纳入不变性条件中。即如果变量与其他状态变量之间存在依赖关系或约束，volatile 并不能保证变量之间的一致性（不变性条件）
  - 在访问变量时不需要加锁。
- 加锁机制既可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。
### 3.2 发布与逸出
- 详见[UnsafeStates.java](src/cn/learn/juc/chapter3/escape/UnsafeStates.java)
- 当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态
### 3.3 线程封闭(Thread Confinement)
- 线程封闭是指在某个线程中，某个对象只能在该线程中访问，不能在另一个线程中访问。
- 线程封闭的常见应用时JDBC(Java Database Connectivity)的Connection对象。JDBC规范并不要求Connection对象必须是线程安全的。在典型的服务器应用程序中，线程从线程池中获取一个Connection对象，并且用该对象来处理请求，使用完后再将对象返还给线程池。由于大多数请求（例如Servlet请求）都是由单线程采用同步的方式来处理，并且在Connection对象返回之前，连接池不会再将它分配给其他线程，因此，这种连接管理模式在处理请求时隐含地将Connection对象封闭在线程中。
  - 因此，这种连接管理模式在处理请求时隐含地将Connection对象封闭在线程中。采用的是ThreadLocal技术，ThreadLocal 提供了一种将数据与当前线程绑定的机制，每个线程都有自己的独立副本
  - ThreadLocal 是一种很好的方式来封闭 Connection 对象，使得每个线程都有自己的 Connection，这样可以避免线程之间的竞争和资源共享问题。
#### 3.3.1 栈封闭
- 栈封闭是指在函数调用过程中，某个变量只能在当前栈帧中访问。
- 栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个变量。
#### 3.3.2 ThreadLocal类
- ThreadLocal类是JDK提供的一个线程封闭类，它为每个线程都创建了一个独立的变量副本，从而保证了线程安全。
- 维持线程封闭性的一种更规范的方法是使用ThreadLocal，这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal提供了get和set等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此get总是返回由当前执行线程在调用set时设置的最新值。
- ThreadLocal对象通常用于防止对可变的单示例变量(Singleton)或全局变量进行共享。例如，在单线程应用程序中可能会维持一个全局的数据库连接，并在程序启动时初始化这个连接对象，从而避免在调用每个方法时都需要传递一个Connection对象。由于JDBC的连接对象不一定是线程安全的，因此，当多线程应用程序在没有协同的情况下使用全局变量时，就不是线程安全的。通过将JDBC的连接保存到ThreadLocal对象中，每个线程都会有属于自己的连接。
  - 详见[ThreadLocalApp.java](src/cn/learn/juc/chapter3/confine/ThreadLocalApp.java)
- 当某个线程初次调用ThreadLocal.get方法时，就会调用initialValue来获取初始值。
- ThreadLocal 对象本质上充当一个容器，帮助将线程与其内部保存的值关联起来。每个线程都有一个独立的 ThreadLocalMap，而 ThreadLocal 对象作为这个 Map 中的键，值就是我们通过 ThreadLocal 设置的值。
- 我们不能滥用ThreadLocal，它应该只用于那些在多个线程间共享的变量，例如，在多线程环境下，每个线程都有自己的数据库连接，每个线程都有自己的日志记录器，每个线程都有自己的线程池，等等。
- 它降低了代码的可重用性，并在类之间引入隐含的耦合性。
### 3.4 不变性
- 不变性是指对象在某个状态下，其状态不会被修改，并且该状态由构造函数去控制。
- 满足同步需求的另一个方法就是使用不可变对象（Immutable Object）
- 不可变对象一定是线程安全的
- 如果某个对象在此间后其状态就不能被修改，那么这个对象就称为不可变对象。线程安全性时不可变对象的固有属性之一。
  - 当不可变对象不一定时线程安全的
  - 构造函数是对象确保初始化的最后一道屏障
- 不可变性不等于将对象中的所有的域都声明为final类型，即使对象中所有的域都是final类型的，这个对象也仍然是可变的，因为final类型的域中可以保存对可变对象的引用。
  - 详见[ImmutableApp.java](src/cn/learn/juc/chapter3/ImmutableApp.java)
  - 还得看final修饰的域持有的对象是否也是不可变对象
- 当满足一下条件时，对象才是不可变的：
  - 对象创建后其状态不能被更改
  - 对象的所有域都是final类型
  - 对象时正确创建的（在对象的创建期间，this没有逸出）
#### 3.4.1 final域
- final类型的域锁不可修改的，但如果final域所引用的对象是可变的，那么这些被引用的对象是可以修改的。
- 在jaa内存模型中，final能确保初始化过程中的安全性，从而可以不受限地访问不可变对象，并且共享这些对象时无需同步。
  - final的可见性是指被final修饰的字段在构造器中一旦被初始化了，并且构造器没有把“this”的引用传递出去，那么在其他线程中就能看到final字段的值。
- 每当需要对一组相关数据以原子的方式执行某个操作时，都可以考虑创建一个不可变的类来包含这些数据。
- 对于在访问和更新对歌相关变量时出现的竞争条件问题，可以通过将这些变量保存在一个不可变对象中来消除。
  - 如果是一个可变对象，那么就必须使用锁来确保原子性。
  - 如果是一个不可变对象，那么当线程获得了对该对象的引用后，就不必担心另一个线程修改了该对象的状态
### 3.5 安全发布
- 到目前为止，我们重点讨论的是如何确保对象不被发布，例如让对象封闭在线程或另一个对象的内部。
- 某些情况下我们希望在多个线程间共享对象，此时必须确保安全地进行共享。
- 要安全地发布一个对象下，对象的引用以及对象的状态必须同时对其他线程可见，一个正确构造的对象可以通过以下方式来安全地发布：
  - 在静态初始化函数中初始化一个对象引用
  - 将对象的引用保存到volatile类型的域或者AtomicReference对象中
  - 将对象的引用保存到某个正确构造对象的final类型域中
  - 将对象的引用保存到一个由锁保护的域中
- 通常情况下，要发布一个静态构造的对象，最简单和最安全的方式是使用静态的初始化器：
  ```java
    public static Holder holder = new Holder(42);
   ```
- 静态初始化器是由JVM在类初始化阶段执行。由于在JVM内部存在同步机制，因此通过这种方式可以被安全发布。
#### 3.5.1 可变对象
- 如果对象在构造后可以修改，那么安全发布只能保证“发布当时”状态的可见性
- 对于可变对象，不仅在发布对象时需要使用同步，而且在每次对象访问时同样需要使用同步来确保后续修改操作的可见性
- 要安全地共享可变对象，这些对象必须被安全地发布，并且必须时线程安全的或者由某个锁保护起来

#### 3.5.2 总结
在并发程序中使用和共享对象时，可以使用一些实用的策略，包括：
- 线程封闭：线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
- 只读共享：在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象（只读对象）。
- 线程安全共享：线程安全的对象在内部实现同步，因此多个线程可以通过对象的公开方法来访问而不需要进一步的同步。
- 保护对象：被保护的对象只能通过持有特定的锁来访问。保护对象包括封装在其他线程安全对象中的对象，以及已发布的并且由某个特定锁保护的对象。

## chapter4-对象的组合
### 4.1 设计线程安全的类
- 在操作中还会包含一些后验条件来判断状态迁移是否是有效的。如果Counter的当前状态为17，那么下一个有效状态只能是18。当下一个状态需要依赖当前状态时，这个操作就必须是一个复合操作。
- 并非所有的操作都会在状态转换上施加限制，例如，当更新一个保存当前温度的变量时，该变量正确的状态并不会影响计算结果。
#### 4.1.1 依赖状态的操作
- 类的不变性条件与后验条件约束了在对象上有哪些状态和状态转换是有效的。在某些对象的方法中还包含一些基于状态的先验条件（Precondition）。例如，不能从空队列中移除一个元素，在删除元素前，队列必须处理“非空的”状态。
- 如果在某个操作中包含有基于状态的先验条件，那么这个操作被称为依赖状态的操作。
- 在单线程程序中，如果某个操作无法满足先验条件，那么就只能失败。但在并发程序中，先验条件可能会由于其他线程执行 的操作而变为真。在并发程序中要一直等到先验条件为真，然后再执行该操作。
### 4.2 实例封闭
- 如果某个类不是线程安全的，那么可以通过多种技术使其在多线程程序中安全地使用。你可以确保该对象只能由单个线程访问（线程封闭），或者通过一个锁保护对该对象的所有访问。
- 封装简化了线程安全类的实现过程，它提供了一种实例封闭机制（Instance Confinement），通常也简称为“封闭”。
- 被封装对象一定不能超出它们既定的作用域。对象可以封闭在类的一个实例（例如作为类的一个私有成员）中，或者封闭在某个作用域内（例如作为一个局部变量），再或者封闭在线程内（例如在某个线程中将对象从一个方法传递到另一个方法，而不是多个线程之间共享该对象）。
- 实例封闭式构建线程安全类的最简单的一个方式，他还使得在锁策略的选择上拥有更多的灵活性。在Person中使用它的内置锁保护它的状态，但对于其他形式的锁来说，只要自始至终都使用同一个锁，就可以保护状态。
- 实例封闭还使得不同的状态变量可以由不同的锁来保护。
#### 4.2.1 监视器模式
- java监视器模式仅仅是一种编写代码的约定，对于任何一种锁对象，只要自始至终都使用该锁对象，都可以用来保护对象的状态，如下给出了如何使用私有锁来保护状态。
  ```java
    public class PrivateLock {
        private final Object myLock = new Object();
        private String widget;
        void someMethod() {
            synchronized (myLock) {
                // 访问或修改widget的状态
            }
        }
    }
   ```
- 使用私有的锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁），有许多优点。私有的锁对象可以将锁封装起来，使客户端无法得到锁，但客户端代码可以通过公有方法来访问锁，以便参与到它的同步策略中。
- 也可以通过在返回客户端代码之前复制可变的数据来维持线程安全性，如[SafeStates.java](src/cn/learn/juc/chapter3/immutable/SafeStates.java)，通常情况下，这并不存在性能问题，但在某些情况下，例如在处理大文件时，可能会导致内存溢出。
  - 因为每次创建一个新对象，所以每次调用都会创建一个新的对象，并且每次调用都会复制一份数据。虽然实际的数据发生了变化，但是返回的信息却保持不变。
### 4.3 为现有类添加原子操作
#### 4.3.1 客户端加锁
- 客户端加锁是指，对于使用某个对象X的客户端代码，使用X本身用户保护其状态的锁来保护这段客户端代码。
#### 4.3.2 组合
- 当为现有的类添加一个原子操作时，有一个更好的方法：组合（Composition），例如ImprovedList通过将List对象的操作委托给底层的List实例来实现List的操作。
- ImproveList通过自身的内置锁增加了一层额外的加锁，它并不关心底层的List是否是线程安全的，即使List不是线程安全的活着修改了它的加锁实现，ImprovedList也会提供一致的加锁机制来实现线程安全性。
## chapter5-基础构建模块
### 5.1 同步容器类
- 同步容器类包括Vector和HashTable，这些同步的封装器类是由Collections.synchronizedXxx等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态全部封装起来，并对每个公有方法都进行同步，使得每次只有一个线程能访问容器的状态。
#### 5.1.1 同步容器类的问题
- 同步容器类都是线程安全的，但在某些情况下可能需要额外的客户端加锁来保护复合操作。
- 容器创建的复合操作包括
  - 迭代（反复访问元素，直到遍历完容器内所有元素）
  - 跳转（根据指定顺序做到当前元素的下一个元素）
  - 条件运算，例如“若没有则添加”（检查在Map中是否存在键值K，如果没有，则加入键值对(K,V)）。
- 在同步容器类中，这些复合操作在没有客户端加锁的情况下表面上看是线程安全的，但当其他线程并发地修改容器时，它们可能会表现出意料之外的行为。例如，在迭代过程中，如果另一个线程删除了当前元素，那么迭代器将抛出ConcurrentModificationException。
- 同步容器类要遵守同步策略，即支持客户端加锁，因此可能会产生一些新的操作，只要我们知道应该使用哪一种锁，那么这些新操作就与容器的其他操作一样帅原子操作。
- 同步容器类通过其自身的锁来保护它的每个方法。通过获取容器类的锁，我们可以使getList和delList称为原子操作，并确保Vector的大小在调用size和get之间不会发生变化。
  - 详见[VectorV1.java](src/cn/learn/juc/chapter5/VectorV1.java)和[VectorV2.java](src/cn/learn/juc/chapter5/VectorV2.java)
- 在迭代操作时正确性要依赖于运气，即在调用size和get之间没有线程会修改Vector。在单线程环境中，这种假设完全成立，但在有其他线程并发地修改Vector时，则可能导致麻烦。
  - 与getList一样，如果在对Vector进行迭代时，另一个线程删除了一个元素，并且这两个操作交替执行，那么这种迭代方法将抛出ArrayIndexOutOfBoundsException异常。
#### 5.1.2 迭代器与ConcurrentModificationException
- 对容器类进行迭代的标准方式是使用Iterator，如果在迭代时，有其他线程并发地修改容器，那么即使是使用迭代器也无法避免在迭代期间对容器加锁。应该是在设计同步容器类的迭代器时并没有考虑到并发修改的问题，并且它们表现出的行为时“及时失败”（fail-fast）的。
- 这意味着，当它们发现容器在迭代过程中被修改时，就会抛出一个ConcurrentModificationException
  - 使用java8的foreach内部迭代，可以避免这种问题。
- 这种“及时失败”的迭代器并不是一种完备的处理机制，而只是”善意地“捕获并发错误，因此只能作为并发问题的预警指示器。它们采用的实现方式是，将计数器的变化与容器关联起来：如果在迭代期间计数器被修改，那么hasNext或next将抛出ConcurrentModificationException。然而，这种监察室在没有同步的情况下进行的，因此可能会看到失效的计数值，而迭代器可能并没有意识到已经发生了修改。
### 5.2 并发容器
- java提供了多种并发容器来改进同步容器的性能。同步容器将所有对容器状态的访问都串行化，以实现它们的线程安全性。这种方法的代价是严重降低并发性，当多个线程竞争容器的锁时，吞吐量将严重减低。
- 并发容器就是针对多个线程访问设计的，增加了ConcurrentHashMao，用来替代同步且基于散列的Map，以及CopyOnWriteArrayList，用来替代同步且基于数组的List，用于在遍历操作为主要操作的情况下代替同步的List。在新的ConcurrentMap接口中增加了对一些常见复合操作的支持，例如“没有则添加”、替换以及有条件删除等。
- 通过并发容器来代替同步容器，可以极大地提高伸缩性并降低风险。
- java页增加了两种新的容器类型：Queue和BlockingQueue。Queue用来临时保存一组等待处理的元素。它提供了几种实现，包括：ConcurrentLinkedQueue，这是一种传统的先进先出的队列，以及PriorityQueue，这是一个（非并发）优先队列。
- Queue上操作的不会阻塞，如果队列为空，那么获取元素的操作将返回空值。虽然可以用List来模拟Queue的行为——事实上，正是通过LinkedList来实现Queue的，但还需要一个Queue的类，因为它能去掉List的随机访问需求，从而实现更高效的并发。
- BlockingQueue扩展了Queue，增加了可阻塞的插入和获取等操作。
  - 如果队列为空，那么获取元素的操作将一直阻塞，直到队列中出现一个可用的元素。
  - 如果队列已满（对于有界队列来说），那么插入元素的操作将一直阻塞，直到队列中出现可用的可见。在“生产者——消费者”这种设计模式中，阻塞队列上非常有用的。
#### 5.2.1 ConcurrentHashMap
- 同步容器类在执行每个操作期间都持有一个锁。在一些操作中，例如HashMap.get或List.contains，可能包含大量的工作：当遍历散列桶或链表来来查找某个特定的对象时，必须在许多元素上调用equals
- 在基于散列的容器中，如果hashCode不能很均匀地分布散列值，那么容器中的元素就不会均匀地分布在整个容器中。某些情况下，某个糟糕的散列函数还会把一个散列表变成线性链表。
- 当遍历很长的链表并且在某些或者全部元素上调用equals方法时，会花费很长的时间，而其他线程在这段时间内都不能访问该容器。
- ConcurrentHashMap与其它并发容器一起增强了同步容器类：它们提供的迭代器不会抛出ConcurrentModificationException，因此不需要在迭代过程中对容器加锁。
- ConcurrentHashMap还支持putIfAbsent、replace和remove等操作。返回的迭代器具有弱一致性（Weakly Consistent），而并非“及时失败”。弱一致性的迭代器可以容忍并发的修改，当创建迭代器时会遍历已有的元素，并可以（但不保证）在迭代器被构造后将修改操作反映给容器。
- 由于size返回的结果在计算时可能已经过期了，它实际是只是一个估计值，因此允许size返回一个近似值而不是一个精确值。详见[ConcurrentHashMapDemo.java](src/cn/learn/juc/chapter5/ConcurrentHashMapDemo.java)
- 在ConcurrentHashMap中没有实现对Map加锁以提供独占访问。在HashTable和synchronizedMap中，获取Map的锁能防止其它线程访问这个Map。
-与HashTable和synchronizedMap相比，ConcurrentHashMap有着更多优势，只有当应用程序需要加锁Map以进行独占式访问时，才应该放弃使用ConcurrentHashMap。
#### 5.2.2 额外的原子Map操作
- 由于ConcurrentHashMap不能被加锁来执行独占访问，因此我们无法使用客户端加锁来创建新的原子操作，比如“若没有则添加”、”若相等则移除(Remove-If-Equal)“、”若相等则替换(Replace-If-Equal)“等。 这些都以实现为原子操作并且在ConcurrentMap中接口中已经声明
  ```java
    // 当且仅当K没有相应的映射值才插入
    V putIfAbsent(K key, V value);
    // 当且仅当K呗映射到V时才移除
    boolean remove(K key, V value);
    // 当且仅当K被映射到oldValue时才替换为newValue
    boolean replace(K key, V oldValue, V newValue);
    // 当且仅当K被映射到某个值时才替换为newValue
    V replace(K key, V newValue);
   ```
#### 5.2.3 CopyOnWriteArrayList
- CopyOnWriteArrayList用于替代同步List，在某些情况下它提供了更好的并发性能，并且在迭代期间不需要对容器进行加锁或复制。
- "写入时复制(Copy-On-Write)"容器的线程安全性在于，只要正确地发布一个事实不可变的对象，那么在访问该对象时就不再需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。
- 多个线程可以同时对这个容器进行迭代，而不会彼此干扰或者与修改容器的线程互相干扰。“写入时复制”容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素与迭代器创建时的元素完全一致，而不必考虑之后修改操作所带来的影响。
- 显然，每当修改容器时都会复制底层数组，这需要一定的开销，特别是当容器规模较大时。当且仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”容器。
  - 这个准则很好地描述了许多事件通知系统：在分发通知时需要迭代已注册监听器链表，并调用每一个监听器，在大多数情况下，注册和注销事件监听器的操作远少于接收事件通知的操作。
  - 开源框架维护注册中心就是用的CopyOnWriteArrayList
### 5.3 阻塞队列和生产者消费者模式
- 阻塞队列提供了可阻塞的put和take方法，以及支持定时的offer和poll方法。如果队列已经满了，那么put方法将阻塞直到有空间可用；如果队列为空，那么take方法将会阻塞直到有元素可用。
- 队列可以说有界也可以是无界的，无界队列永远不会充满，因此无界队列上的put方法也永远不会阻塞。
  - LinkedBlockingQueue 无界队列
  - ArrayBlockingQueue 有界队列
- offer 和 poll 方法与 put 和 take 方法的主要区别在于是否会阻塞线程

| 方法                                          | 阻塞性           | 超时时间     | 返回值                            |
|-----------------------------------------------|------------------|--------------|-----------------------------------|
| **`offer(E e)`**                              | 非阻塞           | 无           | 成功返回 `true`，满时返回 `false` |
| **`offer(E e, long timeout, TimeUnit unit)`** | 阻塞，限时等待   | 有限时等待   | 成功返回 `true`，超时返回 `false` |
| **`poll()`**                                  | 非阻塞           | 无           | 成功返回元素，空时返回 `null`     |
| **`poll(long timeout, TimeUnit unit)`**       | 阻塞，限时等待   | 有限时等待   | 成功返回元素，超时返回 `null`     |
| **`put(E e)`**                                | 阻塞，无限等待   | 无           | 成功插入，满时阻塞直到有空间      |
| **`take()`**                                  | 阻塞，无限等待   | 无           | 成功返回元素，空时阻塞直到有元素  |

- 阻塞队列支持生产者——消费者这种设计模式。该模式将“找出需要完成的工作”与“执行工作”这两个过程分离开来，并把工作项放入一个“待完成”列表中以便在随后处理，而不是找出后立即处理。
- 生产者——消费者模式能简化开发过程，因为它消除了生产者类和消费者类之间的代码依赖性。
- 该模式还将生产数据的过程和使用数据的过程解耦开来以简化工作负载的管理，因为这两个过程在处理数据的速率上有所不同。
- 在基于阻塞队列构建的生产者——消费者设计中，但数据生成时，生产者把数据放入队列，而当消费者准备处理数据时，将从队列中获取数据。生产者不需要知道消费者的标识或数量，或者它是否是唯一的生产者，而只需将数据放入队列即可。
- 同样，消费者也不需要知道生产者是谁，或者工作来自何处。
- BlockingQueue简化来了生产者——消费者设计模式的实现过程，它支持任意数量的生产者和消费者。
- 如果生产者生成工作的速率比消费者处理工作的速率快，那么工作项会在队列中累积起来，最终耗尽内存。
- 阻塞队列同样提供了一个offer方法，如果数据项不能被添加到队列中，那么将返回一个失败状态。
- 在类库中包含了BlockingQueue的多种实现，其中，LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，二者分别与LinkedList和ArrayList类似，但比同步List拥有更好的并发性能。
- PriorityBlockingQueue是一个按优先级排序的队列，当你希望按照某种顺序而不是FIFO来啊处理元素时，这个队列将非常有用。正如其他有序的容器一样，PriorityBlockingQueue既可以根据元素的自然顺序来比较元素（如果它们实现了Comparable方法），也可以使用Comparator来比较。
  - Comparable 是一个内置接口，通常用于定义对象自身的自然排序。如果一个类实现了 Comparable 接口，它就必须覆盖 compareTo() 方法，来定义对象的排序规则。
  - Comparator 是一个外部比较器，用于在类外定义多个不同的排序逻辑。与 Comparable 不同，Comparator 可以定义在多个地方，甚至可以在需要时动态创建。
### 5.4 阻塞方法与中断方法
- 线程看你会阻塞或暂停执行，原因有多种：等待I/O操作结束，等待获得一个锁，等待从Thread.sleep方法中醒来，或是等待另一个线程的计算结果。
- 当线程阻塞时，它通常被挂起，并处于某种阻塞状态（BLOCKED、WAITING或TIMED_WAITING）。阻塞操作与执行时间很长的普通操作的区别在于，被阻塞的线程必须等待某个不受它控制的事件发生后才能继续执行
  - 例如等待I/O操作完成，等待某个锁变成可用，或者等待外部计算的结束。
  - 这些方法可能会长时间阻塞线程，因此设计了 InterruptedException，让你有机会处理中断信号。当线程在阻塞状态下被其他线程调用 interrupt() 方法时，它会抛出 InterruptedException，让调用代码有机会提前结束阻塞状态。
- BlockingQueue的put和take等方法会抛出受检查异常（Checked Exception）InterruptedException，这与类库中其他一些方法的做法系统，例如Thread.sleep。当某方法抛出InterruptedException时，表示该方法时一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。
- Thread提供了interrupt方法，用于中断线程或者查询线程是否已经被中断。每个线程都有一个布尔类型的属性，表示线程的中断状态，当中断线程时将设置这个状态。
- 中断是一种协作机制。一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作。当线程A中断B时，A仅仅是要求B在执行到某个可以暂停的地方停止正在执行的操作——前提是如果线程B愿意停止下来。虽然在API或者语言规范中并没有为中断定义如何特定的语义，但最常使用中断的情况就是取消某个操作。
  - 方法中对中断请求的响应度越高，就越容易及时取消那些执行时间很长的操作。
- 当在代码中调用了一个将抛出InterruptedException异常的方法时，你自己的方法也就变成了一个阻塞方法，并且必须要处理对中断的响应。对于库代码来说，有两种基本选择：
  - 传递InterruptedException：避开这个异常通常是最明智的策略——只需把InterruptedException传递给方法的调用者。传递InterruptedException的方法包括，根本不捕获该异常，然后在执行某个简单的清理工作后再次抛出这个异常。
  - 恢复中断：有时候不能抛出InterruptedException，例如当代码是Runnable的一部分时。在这些情况下，必须捕获InterruptedException，并通过调用当前线程上的interrupt方法恢复中断状态，这样在调用栈更高层的代码将看到引发了一个中断。
  ```java
    try {
        // 业务逻辑
    } catch (InterruptedException e) {
        // 恢复被中断的状态
        Thread.currentThread().interrupt();
    }
   ```
- 出现InterruptedException时不应该做的事情时，捕获它但不做出任何响应。这将使调用栈上更高层的代码无法对中断采取处理措施，因为线程被中断的证据已经丢失。换句话说，我们不应该屏蔽中断。
### 5.5 同步工具类
- 在容器类中，阻塞队列是一种独特的类，它们不仅能作为保存对象的容器，还能协调生产者和消费者等线程之间的控制流，因为take和put等方法将阻塞，直到队列达到期望的状态（队列既非空，也非满）。
- 同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。阻塞队列可以作为同步工具类，其他类型的同步工具类还包括信号量（Semaphore）、栅栏（Barrier）以及闭锁（Latch）。
- 所有的同步工具类都包含一些特定的结构化属性：它们封装了一些状态，这些状态将决定执行同步工具类的线程是继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用语高效地等待同步工具类进入到预期状态。
#### 5.5.1 闭锁
- 闭锁是一种同步工具类，可以延迟线程的角度直到达到最终状态。闭锁的作用相当于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭的，并且没有任何线程可以通过，当到达结束状态时，这扇门会打开并允许所有的线程通过（CountDownLatch的await操作）。当闭锁到达结束状态后，将不会再改变状态，因此这扇门将永远保持打开状态。
- 闭锁可以用来确保某些活动直到其他活动都完成后才继续执行，例如：
  - 确保某个计算在其需要的所有资源都被初始化后才继续执行。
  - 确保某个服务在其一览的其他服务都已经启动之后才启动。每个服务都有一个相关的二元闭锁。当启动服务S时，将首先在S依赖的其他服务的闭锁上等待，在所有依赖的服务都启动后会释放闭锁S，这样其他依赖S的服务才能继续执行
  - 等待直到某个操作的所有参与者（例如，在多玩家游戏中的所有玩家）都就绪再继续执行。在这种情况下，当所有玩家都准备就绪时，闭锁将达到结束状态。详见[GameLatch.java](src/cn/learn/juc/chapter5/latch/GameLatch.java)
- CountDownLatch是一种灵活的闭锁实现，可以在上述各种情况中使用，它可以使一个或多个线程等待一组事件发生。闭锁状态包括一个计数器，该计数器被初始化为一个正数，表示需要等待的事件数量。countDown方法递减计数器，表示有一个事件已经发生了，而await方法等待计数器达到零，这表示所有需要等待的事件都已经发生。如果计数器的值非零，那么await会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。
- 示例详见[TestHarness.java](src/cn/learn/juc/chapter5/latch/TestHarness.java)
  - 启动门将使得住线程能够同时释放所有工作线程，而结束门则使主线程能够等待最后一个线程执行完成，而不是顺序地等待每个线程执行完成。
- CountDownLatch的最佳实践：将一个任务分解为n个互相独立可解决的任务，并创建值为n的CountDownLatch进行处理。
#### 5.5.2 FutureTask
- FutureTask也可以用作闭锁（FutureTask实现了Future的语义，标识一种抽象的可生成结果的计算）。FutureTask标识的计算时通过Callable实现的，相当于一种可生成结果的Runnable，并且可以处于以下三种状态：等待运行（Waiting to run），正在运行（Running）和运行完成（Completed）。“执行完成”表示计算的所有可能结束方式，包括正常结束、由于取消而结束和由于异常结束等。
- 当FutureTask进入完成状态后，它会永远停止在这个状态上。
- Future.get的行为取决于任务的状态。如果任务创建已经完成，那么get会立即返回结果，否则get将阻塞直到任务进入完成状态，然后返回结果或者抛出异常。
  - FutureTask将计算结果从执行计算的线程传递到获取这个结果的线程，而FutureTask的规范确保了这种传递过程能实现结果的安全发布。
    - Callable表示的任务可以抛出受检查异常的或未受检查的异常，并且任何代码都可能抛出一个Error。无论任务代码抛出什么异常，都会被封装到一个ExecutionException中，并在Future.get中被重新抛出。
      - 这将使调用get的代码变得复杂，因为它不仅需要处理可能出现的ExecutionException（以及未检查的CancellationException），而且还由于Execution Exception是作为一个Throwable类返回的，因此处理起来并不容易。
        ```java
        import java.util.concurrent.ExecutionException;       
        try {
            futureTask.get();
        } catch (ExecutionException e) {
            Throwable cause = e.getCause();
            // 细分异常 call方法默认抛出Exception
            if (cause instanceof RuntimeException) {
                throw (RuntimeException) cause;
            }
        }
         ```
        
