# 本模块选自《java并发编程实战》

## chapter1
### 1.1 前言

## chapter2
### 2.1 什么是线程安全性?
- 竞态条件(Race Condition)
  - 在[UnsafeSequence.java](src/cn/learn/juc/chapter1/UnsafeSequence.java)中存在竞态条件
  - 当某个计算的准确性取决于多个线程交替执行的时序，那么就会发生竞态条件
  - 最常见的竞态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能已经失效的观测结果来决定下一步操作：首先观测某个条件是否为真（例如文件X不存在），然后根据这个观察结果采取相应的动作（创建文件X），但事实上，在你观察到这个结果以及开始筹建文件之间，观察结果可能变得无效（另一个线程在这个期间创建了文件X），从而导致各种问题（未预期的异常、数据被覆盖、文件被破坏等）
  - 使用“先检查后执行”的一种创建情况就是延迟初始化，延迟初始化的目的是将初始化操作到对象使用的时候才执行，同时确保只初始化一次
- 无状态的对象一定是线程安全的 例如Servlet 即两个线程之间没有共享状态
  - 例如Servlet没有状态（属性）， 所有的变量都只存在于线程栈的局部变量中，并且只能由当前线程访问，和其他线程并没有共享状态，就好像在访问不同的实例，由于线程访问无状态对象的行为并不会影响其他线程
- 不可变对象一定是线程安全的 (详见[WithPrivateFinalFiled.java](src/cn/learn/juc/chapter2/WithPrivateFinalFiled.java))
### 2.2 原子性
- [UnsafeSequence.java](src/cn/learn/juc/chapter1/UnsafeSequence.java)和[LazyInitRace.java](src/cn/learn/juc/chapter2/LazyInitRace.java)包含了一组需要以原子方式进行（或者说不可分割）的操作。要避免竞态条件问题，就必须在某个线程修改该变量时，通过某种方式防止其他线程使用这个变量，从而确保其他线程只能在修改操作完成之前或者之后读取和修改状态，而不是在修改状态的过程中。
- 复合操作：“先检查后执行”以及“读取-修改-写入”等操作称为复合操作；包含了一组必须以原子方式执行的操作已确保线程安全性
- 并发环境中的原子性与事务应用中的原子性具有相同的含义——一组语句被作为一个不可分割的单元被执行
### 2.3 加锁机制
#### 2.3.1 内置锁
- java提供了一种内置的锁机制来支持原子性：同步代码块（Synchronized Block），同步代码块包含两部分：一个作为锁的对象引用，一个作为由这个锁保护的代码块。以关键字synchronized修饰的代码块就是一个同步代码块，它包含的代码块就是由这个锁保护的代码块，锁对象可以是任意的对象，但必须是同一个对象，否则将无法保证同步。来修饰的方法就锁一种横跨整个方法体的同步代码块。
  ```java
    // lock为锁的对象引用
    synchronized(lock){
        // 访问或修改由lock保护的共享状态
    }
    ```
  - 其中该同步代码块的锁就是这个方法调用所在的对象（对象锁/实例锁）
  - 静态的synchronized方法方法以Class对象作为锁（类锁）
  - 线程在加入同步代码块之前会自动获得锁，并且在退出同步代码块时自动释放锁，而无论是通过正常的控制流程退出还是通过抛出异常而退出，都会释放锁。
  - java的内置锁相当于锁一种互斥锁，这意味着最多最有一个线程能够持有这种锁，当线程A尝试获取一个由线程B持有的锁时，线程A必须等待或者阻塞，知道线程B释放这个锁，如果线程B永远不释放锁，那么线程A也会永远地等下去。
#### 2.3.2 重入
- 当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会被阻塞。然而，由于内置锁是可重入的，异常如果某个线程试图获取一个已经由它自己持有的锁，那么这个请求将会被允许，而不会阻塞。
- “重入”意味着获取锁的操作粒度锁“线程”，而不是“调用”
- 内部实现：为每个锁关联一个获取计数值和一个所有者线程。当计数值为0时，这个锁就被认为是没有被任何线程持有。当线程请求一个未被持有的锁时，JVM将记下这个锁的持有者，并且将获取计数值置为1。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减。当计数值为0时，这个锁将被释放。
### 2.4 用锁来保护状态
- 访问共享状态的复合操作，例如读取-修改-写入或者延迟初始化（先检查后执行），都必须锁原子操作以避免产生竞态条件。
- 如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。并且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。
  - 记住是所有位置，包括读取操作，详见[AtomicityTest.java](src/cn/learn/juc/chapter2/AtomicityTest.java)
  - 只有在写入共享变量才需要同步这个思想是错误的
- 常见加锁约定：将所有的可变状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的路径都进行同步，使得在该对象上不会发生并发访问。
- 当你在 Java 中对某个对象使用 synchronized 关键字获取该对象的锁时，锁定的并不是整个对象，而是对特定的 代码块或方法 进行同步控制。其他线程仍然可以访问该对象的未加锁部分，也就是说，锁定并不意味着对整个对象的独占访问。
- 并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。
- 当某个变量由锁保护时，意味着在每次访问这个变量时都需要首先获得锁，这样就确保在同一时刻只有一个线程可以访问这个变量，当类的不变性条件涉及多个状态变量时，那么还有另一个需求：在不变性条件中的每个变量都必须由同一个锁来保护。因此可以在单个原子操作访问或更新这些变量，从而确保不变性条件不被破坏。
- 示例：同步方法的复合不一定锁死线程安全
  ```java
    if (!list.contains(element))
        list.add(element)
   ```
  - 虽然contains和add等方法都是原子方法，但是在上面这个“如果不存在则添加(put-if-absent)”的操作中仍然存在竞态条件。
  - 虽然synchronized方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还需要额外的加锁机制。
### 2.5 活跃性与性能
- 通过缩小同步代码块的作用范围，我们可以很容易地做到既确保Servlet的并发性，同时又维护线程安全性。要确保同步代码块不要过小，并且不要讲本身应是原子的操作拆分到多个同步代码块中。应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而在这些操作的执行过程中，其他线程可以访问共享变量。